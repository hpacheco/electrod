(*******************************************************************************
 * electrod - a model finder for relational first-order linear temporal logic
 * 
 * Copyright (C) 2016-2024 ONERA
 * Authors: Julien Brunel (ONERA), David Chemouil (ONERA)
 * 
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * 
 * SPDX-License-Identifier: MPL-2.0
 * License-Filename: LICENSE.md
 ******************************************************************************)

open Containers

let unzip_iter iter =
  let a_rev = ref [] in
  let b_rev = ref [] in
  Iter.iter
    (fun (a, b) ->
       a_rev := a :: !a_rev;
       b_rev := b :: !b_rev)
    iter;
  (Iter.of_list (List.rev !a_rev), Iter.of_list (List.rev !b_rev))

(* automatically generated by Dune *)
let nuXmv_default_script = Scripts.nuXmv_default_script
let nuSMV_default_script = Scripts.nuSMV_default_script
let nuXmv_default_bmc_script = Scripts.nuXmv_default_bmc_script
let nuSMV_default_bmc_script = Scripts.nuSMV_default_bmc_script

module Make_SMV_LTL (At : Solver.ATOMIC_PROPOSITION) :
  Solver.LTL with module Atomic = At = struct
  module I = Solver.LTL_from_Atomic (At)
  include I

  module PP = struct
    open Fmtc

    let rainbow =
      let r = ref 0 in
      fun () ->
        let cur = !r in
        incr r;
        match cur with
        | 0 -> `Magenta
        | 1 -> `Yellow
        | 2 -> `Cyan
        | 3 -> `Green
        | 4 -> `Red
        | 5 ->
            r := 0;
            `Blue
        | _ -> assert false

    (* [upper] is the precedence of the context we're in, [this] is the priority
       for printing to do, [pr] is the function to make the printing of the
       expression *)
    let rainbow_paren ?(paren = false) ?(align_par = true) upper this out pr =
      (* parenthesize if specified so or if  forced by the current context*)
      let par = paren || this < upper in
      (* if parentheses are specified, they'll be numerous so avoid alignment of
         closing parentheses *)
      (* let align_par = not paren && align_par in *)
      if par then (
        (* add parentheses *)
        let color = rainbow () in
        if align_par then Format.pp_open_box out 0 else Format.pp_open_box out 2;
        styled color string out "(";
        if align_par then Format.pp_open_box out 2;
        (* we're adding parentheses so precedence goes back to 0 inside of
           them *)
        pr 0;
        if align_par then (
          Format.pp_close_box out ();
          cut out ());
        styled color string out ")";
        Format.pp_close_box out ())
      else
        (* no paremtheses *)
        (* so keep [this] precedence *)
        pr this

    let infixl ?(paren = false) ?(align_par = true) upper this middle left right
        out (m, l, r) =
      rainbow_paren ~paren ~align_par upper this out @@ fun new_this ->
      (* new_this is this or 0 if parentheses were added *)
      left new_this out l;
      sp out ();
      styled `Bold middle out m;
      sp out ();
      right (new_this + 1) out r

    (* left associativity => increment the precedence *)

    let infixr ?(paren = false) ?(align_par = true) upper this middle left right
        out (m, l, r) =
      rainbow_paren ~paren ~align_par upper this out @@ fun new_this ->
      left (new_this + 1) out l;
      sp out ();
      styled `Bold middle out m;
      sp out ();
      right new_this out r

    let infixn ?(paren = false) ?(align_par = true) upper this middle left right
        out (m, l, r) =
      rainbow_paren ~paren ~align_par upper this out @@ fun new_this ->
      left (new_this + 1) out l;
      sp out ();
      styled `Bold middle out m;
      sp out ();
      right (new_this + 1) out r

    let prefix ?(paren = false) ?(align_par = true) upper this pprefix pbody out
        (prefix, body) =
      rainbow_paren ~paren ~align_par upper this out @@ fun new_this ->
      styled `Bold pprefix out prefix;
      pbody (new_this + 1) out body

    let pp_atomic = At.pp

    let pp_tcomp out (t : tcomp) =
      pf out "%s"
      @@
      match t with
      | Lte -> "<="
      | Lt -> "<"
      | Gte -> ">="
      | Gt -> ">"
      | Eq -> "="
      | Neq -> "!="

    (* Generates an SMV signed word consisting of *length_0* 0 on the left and *bw - length_0* 0 after.*)
    (*let generate_mask length_0 bw =
      let beg_mask = List.init length_0 (fun _ -> 0) in
      let end_mask = List.init (bw - length_0) (fun _ -> 1) in
      let mask_list = List.append beg_mask end_mask in
      let prefix =  "0sb" ^ (string_of_int bw) ^ "_" in
      prefix ^ (List.fold_left (fun s i -> s ^ (string_of_int i) ) "" mask_list)
    *)

    (* From NuXmv documentation, from high to low (excerpt, some precedences are ignored because they are not used)

       !

       - (unary minus)

       * / mod

       + -

       << >>

       = != < > <= >=

       &

       | xor xnor

       (... ? ... : ...)

       <->

       -> (the only right associative op)


       NOTE: precedences for LTL connectives are not specified, hence we force parenthesising of these.
    *)

    let pp ?(next_is_X = true) bitwidth auxiliaries variables upper out f =
      let rec pp upper out f =
        assert (upper >= 0);
        match f with
        | True -> pf out "TRUE"
        | False -> pf out "FALSE"
        | Auxiliary v ->
            auxiliaries := Iter.cons v !auxiliaries;
            pf out "%a" Symbol.pp v
        | Atomic at ->
            variables := Iter.cons at !variables;
            pf out "%a" pp_atomic at
        (* tweaks, here, to force parenthese around immediate subformulas of Imp
             and Iff as their precedence may not be easily remembered*)
        | Imp (p, q) -> infixr ~paren:true upper 1 string pp pp out ("->", p, q)
        | Iff (p, q) -> infixl ~paren:true upper 2 string pp pp out ("<->", p, q)
        | Ite (c, t, e) ->
            (* SMV's ...?...:... or case...esac expression cannot be
                 used as nuXmv does not accept these when subexpressions
                 are temporal (seen in various tests). So we rewrite the formula into more basic terms. *)
            pp upper out
            @@ I.Infix.((c @=> lazy t) +&& lazy (I.not_ c @=> lazy e))
        | Or (p, q) -> infixl ~paren:true upper 4 string pp pp out ("|", p, q)
        (* force parenthses as we're not used to see the Xor connective and so its precedence may be unclear *)
        | Xor (p, q) -> infixl ~paren:true upper 4 string pp pp out ("xor", p, q)
        | And (p, q) -> infixl ~paren:true upper 5 string pp pp out ("&", p, q)
        | Comp (op, t1, t2) ->
            infixn upper 6 pp_tcomp pp_term pp_term out (op, t1, t2)
        | Not p -> prefix upper 9 string pp out ("!", p)
        (* no known precedence for temporal operators so we force parentheses and
             use as the "this" precedence that of the upper context*)
        | U (p, q) -> infixl ~paren:true upper upper string pp pp out ("U", p, q)
        | R (p, q) -> infixl ~paren:true upper upper string pp pp out ("V", p, q)
        | S (p, q) -> infixl ~paren:true upper upper string pp pp out ("S", p, q)
        | T (p, q) -> infixl ~paren:true upper upper string pp pp out ("T", p, q)
        | X p when next_is_X ->
            prefix ~paren:true upper upper string pp out ("X ", p)
        | X p ->
            (* next_is _X= false *)
            styled `Bold string out "next";
            pf out "@[(%a@])" (pp 0) p
        | F p -> prefix ~paren:true upper upper string pp out ("F ", p)
        | G p -> prefix ~paren:true upper upper string pp out ("G ", p)
        | Y p -> prefix ~paren:true upper upper string pp out ("Y ", p)
        | O p -> prefix ~paren:true upper upper string pp out ("O ", p)
        | H p -> prefix ~paren:true upper upper string pp out ("H ", p)
      and pp_term upper out (t : term) =
        match t with
        | Num n ->
            if n < 0 then pf out "-0sd%d_%d" bitwidth (-n)
            else pf out "0sd%d_%d" bitwidth n
        | Bin (t1, Plus, t2) ->
            infixl ~paren:true upper 7 string pp_term pp_term out ("+", t1, t2)
        | Bin (t1, Minus, t2) ->
            infixl ~paren:true upper 7 string pp_term pp_term out ("-", t1, t2)
        | Bin (t1, Mul, t2) ->
            infixl ~paren:true upper 8 string pp_term pp_term out ("*", t1, t2)
        | Bin (t1, Div, t2) ->
            infixl ~paren:true upper 8 string pp_term pp_term out ("/", t1, t2)
        | Bin (t1, Rem, t2) ->
            infixl ~paren:true upper 8 string pp_term pp_term out ("mod", t1, t2)
        | Neg t -> prefix upper 9 string pp_term out ("- ", t)
        | AIte (c, t, e) ->
            pf out "@[((%a) ?@ (%a) :@ (%a)@])" (pp 0) c (pp_term 0) t
              (pp_term 0) e
      in
      pp upper out f
  end

  let pp_gather_variables ?(next_is_X = true) bitwidth auxiliaries variables out
      f =
    Fmtc.pf out "@[<hov2>%a@]"
      (PP.pp ~next_is_X bitwidth auxiliaries variables 0)
      f

  let pp out bitwidth f =
    pp_gather_variables bitwidth (ref Iter.empty) (ref Iter.empty) out f

  (* The syntax of SMV forbids temporal connectives in "basic expressions" (other logical connectives are not a problem). On the other hand, Alloy/Electrod allows any combination of terms and formulas. The following function converts such an arbitrary formula into a "stratified" one, that is one where no temporal connective occurs inside a basic term or formula. This is done by replacing any temporal subformula with a fresh variable the value of which is made equivalent to the original subformula. E.g. G ((F (X c)) ? 0 : 1) = 1) is replaced by G((__fxc ? 0 : 1) = 1) & G(__fxc <-> F (X c)). The function works top-down: it loops along formulas and terms and, each time it meets a temporal subformula in a term, it replaces it with a fresh variable and adds the subformula to an accumulated list of subformulas to handle next (as there may be several sibling temporal subformulas, we need a list). Once the list is empty, we're done and we return of all the created formulas (which were also accumulated in another `res` list). The created formulas are NOT prefixed with `always` because the stratification function can be called in the context of TRANS or LTLSPEC. In the latter case, the returned formulas must be prepended a `G`, but in the former, the formula should be put in a TRANS. *)

  let make_auxiliary =
    let r = ref ~-1 in
    fun () ->
      incr r;
      (* the double underscore ensures that these variables won't be displayed in the resulting counter-example yielded by SMV *)
      auxiliary @@ Symbol.make Printf.(sprintf "__aux%d" !r)

  let stratify ~(smv_section : [ `Trans | `Ltlspec ]) (fml : t) : t list =
    let to_process = ref [ fml ] in
    let rec loop res =
      match !to_process with
      | [] -> res
      | f :: tl ->
          to_process := tl;
          let f' = loop_fml ~in_a_term:false f in
          (* CAUTION: the first input formula is expected (at the end of this function) to appear (possibly modified) as the last in `res`. *)
          loop (f' :: res)
    and loop_fml ~in_a_term (f : t) : t =
      match f with
      | X _ | F _ | G _ | Y _ | O _ | H _
      | U (_, _)
      | R (_, _)
      | S (_, _)
      | T (_, _)
        when in_a_term ->
          let v = make_auxiliary () in
          to_process := iff v f :: !to_process;
          v
      | True | False | Atomic _ | Auxiliary _ -> f
      | Not f1 -> not_ (loop_fml ~in_a_term f1)
      | And (f1, f2) ->
          let f2' = loop_fml ~in_a_term f2 in
          and_ (loop_fml ~in_a_term f1) (lazy f2')
      | Or (f1, f2) ->
          let f2' = loop_fml ~in_a_term f2 in
          or_ (loop_fml ~in_a_term f1) (lazy f2')
      | Imp (f1, f2) ->
          let f2' = loop_fml ~in_a_term f2 in
          implies (loop_fml ~in_a_term f1) (lazy f2')
      | Iff (f1, f2) -> iff (loop_fml ~in_a_term f1) (loop_fml ~in_a_term f2)
      | Xor (f1, f2) -> xor (loop_fml ~in_a_term f1) (loop_fml ~in_a_term f2)
      | Ite (fc, ft, fe) ->
          ifthenelse (loop_fml ~in_a_term fc) (loop_fml ~in_a_term ft)
            (loop_fml ~in_a_term fe)
      | Comp (op, t1, t2) -> comp op (loop_term t1) (loop_term t2)
      | X f1 -> next (loop_fml ~in_a_term f1)
      | F f1 -> eventually (loop_fml ~in_a_term f1)
      | G f1 -> always (loop_fml ~in_a_term f1)
      | Y f1 -> yesterday (loop_fml ~in_a_term f1)
      | O f1 -> once (loop_fml ~in_a_term f1)
      | H f1 -> historically (loop_fml ~in_a_term f1)
      | U (f1, f2) -> until (loop_fml ~in_a_term f1) (loop_fml ~in_a_term f2)
      | R (f1, f2) -> releases (loop_fml ~in_a_term f1) (loop_fml ~in_a_term f2)
      | S (f1, f2) -> since (loop_fml ~in_a_term f1) (loop_fml ~in_a_term f2)
      | T (f1, f2) ->
          triggered (loop_fml ~in_a_term f1) (loop_fml ~in_a_term f2)
    and loop_term (t : term) =
      match t with
      | Num _ -> t
      | Neg t1 -> neg (loop_term t1)
      | Bin (t1, op, t2) -> binary (loop_term t1) op (loop_term t2)
      | AIte (fc, tt, te) ->
          ifthenelse_arith
            (loop_fml ~in_a_term:true fc)
            (loop_term tt) (loop_term te)
    in
    let formulas = loop [] in
    match smv_section with
    | `Trans -> formulas
    | `Ltlspec ->
        (* As explained above, we rely on the fact that the original input formula is the last in the `formulas` list. In case of an LTLSPEC, we must preprend all created formulas, EXCEPT this one, with a `G`. *)
        let rec prepend_always_but_last = function
          | [] -> []
          | [ f ] -> [ f ]
          | f :: fs -> always f :: prepend_always_but_last fs
        in
        prepend_always_but_last formulas
end

module Make_SMV_file_format (Ltl : Solver.LTL) :
  Solver.MODEL with type ltl = Ltl.t and type atomic = Ltl.Atomic.t = struct
  type ltl = Ltl.t
  type atomic = Ltl.Atomic.t

  type t = {
    elo : Elo.t;
    init : (string * ltl) Iter.t;
    invariant : (string * ltl) Iter.t;
    trans : (string * ltl) Iter.t;
    property : string * ltl;
  }

  let make ~elo ~init ~invariant ~trans ~property =
    { elo; init; invariant; trans; property }

  type partial_atom = PAtom of Atom.t | PVals of Valuations_list.t * Tuple_set.t
  type partial_tuple = partial_atom list
  
  let to_partial_tuple (t : Tuple.t) : partial_tuple =
      List.map (fun x -> PAtom x) (Tuple.to_list t)
  
  let rec tuple_to_full (t : Tuple.t) (pt : partial_tuple) : Tuple.t =
      let rec tail xs = match xs with
          | [] -> []
          | (PAtom a :: xs) -> List.cons a (tail xs)
          | (PVals _ :: xs) -> failwith "multiple vals: should not happen"
      in let rec go xs = match xs with
          | [] -> []
          | (PAtom a :: xs) -> List.cons a (go xs)
          | (PVals (vs,_) :: xs) -> (Tuple.to_list t) @ tail xs
      in Tuple.of_list1 (go pt)
      
  let partial_atom_to_string a = match a with
      | PAtom a -> [Atom.to_string a]
      | PVals (vs,ts) -> List.init (Tuple_set.inferred_arity ts) (fun _ -> "__")
      
  let rec partial_vals (t : partial_tuple) : (Valuations_list.t * Tuple_set.t) option = match t with
      | [] -> None
      | (PAtom a :: xs) -> partial_vals xs
      | (PVals (vs,ts) :: xs) -> (match partial_vals xs with
          | None -> Some (vs,ts)
          | Some _ -> failwith "more than one valuation set per variable is unsupported")
  
  let join_partial_tuples (t1 : partial_tuple Iter.t) (t2 : partial_tuple Iter.t) : partial_tuple Iter.t =
      Iter.product t1 t2 |> Iter.map (fun (x,y) -> x @ y)
  
  let split_tuples (n:int) (tuples : Tuple_set.t) : Tuple_set.t * Tuple_set.t =
      let (ls,rs) = Tuple_set.to_iter tuples |> Iter.map (fun t -> Tuple.split t n) |> unzip_iter in
      (Tuple_set.of_iter ls,Tuple_set.of_iter rs)
  
  let rec mk_partial_tuples (s : Scope.sup_t) (tuples : Tuple_set.t) : partial_tuple Iter.t =
    match s with
    | SupNode (ts,vs) -> (match vs with
        | None -> Tuple_set.to_iter (Tuple_set.inter ts tuples) |> Iter.map to_partial_tuple
        | Some vs -> Iter.return [PVals (Some vs,tuples)])
    | SupArrow (s1,s2) ->
        let (tuples1,tuples2) = split_tuples (Scope.sup_arity s1) tuples in
        join_partial_tuples (mk_partial_tuples s1 tuples1) (mk_partial_tuples s2 tuples2)

  let tuple_to_string tuple = Fmtc.(str "%a" @@ list ~sep:minus Atom.pp) (Tuple.to_list tuple)

  let pp_plain_decl vartype out name_str tuple_str =
    Fmtc.hardline out ();
    Fmtc.pf out "%s %s-%s : boolean;@\n" vartype name_str tuple_str

  let pp_partial_tuple vartype out name_str (pt : partial_tuple) =
      let tuple_lst = List.concat (List.map partial_atom_to_string pt) in
      match partial_vals pt with
      | None ->
          Fmtc.pf out "%s %s-%a : boolean;@\n" vartype name_str (Fmt.list ~sep:(Fmt.any "-") Fmt.string) tuple_lst
      | Some (vs,ts) ->
          Fmtc.(pf out "%s __%s-%a : 0..%n;@\n" vartype name_str (Fmt.list ~sep:(Fmt.any "-") Fmt.string) tuple_lst (Valuations_list.size vs - 1));
          Tuple_set.iter (fun t ->
              let tuple_str = tuple_to_string (tuple_to_full t pt) in
              let tuple_idxs = Valuations_list.indices_of t vs in
              Fmtc.(pf out "DEFINE %s-%s := __%s-%a in {%a};@\n" name_str tuple_str name_str (Fmt.list ~sep:(Fmt.any "-") Fmt.string) tuple_lst (Fmt.list ~sep:(Fmt.any ", ") Fmt.int) tuple_idxs )
              ) ts

  let pp_sup vartype out name_str (sup : Scope.sup_t) (tuples : Tuple_set.t) =
      Iter.iter (pp_partial_tuple vartype out name_str) (mk_partial_tuples sup tuples)

  let pp_decl elo vartype out (name : Name.t) (tuples : Tuple_set.t) =
    let name_str = Name.to_string name in
    let rel = Domain.get_exn name elo.Elo.domain in
    let scope = Relation.scope rel in
    match scope with
        | Exact ts ->
            Tuple_set.iter (fun t -> pp_plain_decl vartype out name_str (tuple_to_string t)) tuples
        | Inexact (inf,sup) ->
            Tuple_set.iter (fun t ->
                Fmtc.(pf out "DEFINE %s-%s := TRUE;@\n" name_str (tuple_to_string t))
                ) (Tuple_set.inter tuples inf);
            pp_sup vartype out name_str sup (Tuple_set.diff tuples inf)
          
      (*let rel = Domain.get_exn name elo.Elo.domain in
      let scope = Relation.scope rel in
      let valuations = Scope.valuations scope in
      let name_str = Name.to_string name in
      let tuple_to_string tuple =
        Fmtc.(str "%a" @@ list ~sep:minus Atom.pp) (Tuple.to_list tuple) in
      
      (* print variable *)
      Fmtc.(pf out "%s __%s : 0..%n;@\n" vartype name_str (Valuations_list.size valuations - 1));
      
      (* print atoms *)
      Tuple_set.iter (fun tuple ->
          let tuple_str = tuple_to_string tuple in
          if Tuple_set.mem tuple (Scope.inf scope) then Fmtc.(pf out "DEFINE %s-%s := TRUE;@\n" name_str tuple_str)
          else
              let tuple_idxs = Valuations_list.indices_of tuple valuations in
              Fmtc.(pf out "DEFINE %s-%s := __%s in {%a};@\n" name_str tuple_str name_str (Fmt.list ~sep:(Fmt.any ", ") Fmt.int) tuple_idxs ))
          tuples*)

  let pp_decls elo vartype out (atoms : Ltl.Atomic.t Iter.iter) =
      let nmap_update (k,v) m =
          let existing = Name.Map.get k m |> Option.value ~default:Tuple_set.empty in
          Name.Map.add k (Tuple_set.add v existing) m in
      let split_atom at =
          Option.get_exn_or __LOC__ @@ Ltl.Atomic.split at in
      let gatoms =
          Iter.fold (fun acc atom -> nmap_update (split_atom atom) acc) Name.Map.empty atoms in
      Name.Map.iter (fun key value ->
          Fmtc.hardline out ();
          pp_decl elo vartype out key value)
          gatoms

  (* for an enumerated declaration, all the may corresponding to the name must
     be created, even if some cases were cancelled out when printing
     formulas. Indeed, the enumeration also represents a typing invariant which
     would have been a formula too, one that would have spoken about all the
     part. Besides, for 'lone' relations a special value representing the
     absence must be added. *)
  (*let pp_enum_decl elo vartype out (atoms : Ltl.Atomic.t Iter.iter) =
    let module S = Iter in
    let tuple_to_string tuple =
      Fmtc.(str "%a" @@ list ~sep:minus Atom.pp) (Tuple.to_list tuple)
    in
    let atom_name at = Option.get_exn_or __LOC__ @@ Ltl.Atomic.split at in
    let pp_one_decl atom =
      Format.printf "pp_one_decl %a\n" Ltl.Atomic.pp atom;
      let name, _ = atom_name atom in
      let name_str = Name.to_string name in
      (* To avoid changin the generation of LTL formulas, we generate DEFINEs of
         the form `DEFINE x_a1_b1 := x_a1 = b1` (for x of domain arity 1) *)
      let may = Domain.may name elo.Elo.domain |> Tuple_set.to_iter in
      (* where to split tuples (if necessary)? *)
      let dom_ar = Ltl.Atomic.domain_arity atom in
      match dom_ar with
      | None -> assert false
      | Some n when n < 0 -> assert false
      | Some 0 ->
          (* an enumerated set *)
          let may_strings = S.map tuple_to_string may in
          (* add a value for none? *)
          let may_strings_with_empty =
            if Ltl.Atomic.is_partial atom then
              (* add __NONE__ at the end (better for SMV boolean encoding) *)
              S.snoc may_strings "__NONE__"
            else may_strings
          in
          S.iter
            (fun tuple_str ->
              Fmtc.(
                pf out "DEFINE %s-%s := __%s = %s;@\n" name_str tuple_str
                  name_str tuple_str))
            may_strings;
          Fmtc.(
            pf out "%s __%s : %a;@\n" vartype name_str
              (braces_ @@ S.pp_seq string)
              may_strings_with_empty)
      | Some n ->
          (* a partial or total function with domain arity n > 0 *)
          (* first we split all tuples depending on the arity, and regroup
               them in lists of pairs (dom, range) with the same dom *)
          let domains_ranges =
            may
            |> S.map (fun tuple ->
                   Pair.map_same tuple_to_string @@ Tuple.split tuple n)
            |> S.group_by
                 ~hash:(fun (dom, _) -> Hash.string dom)
                 ~eq:(fun (dom1, _) (dom2, _) -> String.equal dom1 dom2)
          in
          (* Msg.debug (fun m ->
           *       m "domains_Ranges = @[<v>%a@]"
           *         Fmtc.(brackets_ @@ S.pp_seq
           *               @@ brackets @@ list ~sep:comma
           *               @@ pair string string) domains_ranges
           *     ); *)
          (* print the DEFINEs *)
          S.iter
            (fun pairs ->
              List.iter
                (fun (dom_str, range_str) ->
                  Fmtc.(
                    pf out "DEFINE %s-%s-%s := __%s-%s = %s;@\n" name_str
                      dom_str range_str name_str dom_str range_str))
                pairs)
            domains_ranges;
          (* now print the vars: we walk along the lists of pairs (dom,
               range) (where every dom is the same) and we use the range to create
               `VAR x_dom : { ... range ...}` *)
          S.iter
            (fun pairs ->
              let dom_str = fst @@ List.hd pairs in
              Fmtc.(
                pf out "%s __%s-%s : %a;@\n" vartype name_str dom_str
                  (braces_ @@ box @@ list ~sep:(sp **> comma) string)
                  (if Ltl.Atomic.is_partial atom then
                   List.rev ("__NONE__" :: List.rev_map snd pairs)
                  else List.map snd pairs)))
            domains_ranges
    in
    atoms
    |> S.sort_uniq (* keep only atoms with different relation names *)
         ~cmp:(fun at1 at2 ->
           Name.compare (fst @@ atom_name at1) (fst @@ atom_name at2))
    |> S.iter (fun at ->
           Fmtc.hardline out ();
           pp_one_decl at)*)

  let pp_count_variables ?(margin = 80) out
      { elo; init; invariant; trans; property } =
    let open Fmtc in
    let module S = Iter in
    (* to gather the variables along printing in the buffer *)
    let variables = ref S.empty in
    let auxiliaries = ref S.empty in
    let old_margin = Format.pp_get_margin out () in
    let bitwidth = Domain.bitwidth elo.Elo.domain in
    Format.pp_set_margin out margin;
    pf out
      "-- Generated by electrod (C) ONERA 2016-2024@\n\
       MODULE main@\n\
       JUSTICE TRUE;@\n";
    (* INIT *)
    Format.pp_open_vbox out 0;
    S.iter
      (fun (elo_str, fml) ->
        match fml with
        | Ltl.True -> ()
        | _ ->
            pf out "%s@\nINIT@\n@[<hv2>%a@];@\n@\n" elo_str
              (Ltl.pp_gather_variables bitwidth auxiliaries variables)
              fml)
      init;
    Format.pp_close_box out ();
    (* INVAR *)
    Format.pp_open_vbox out 0;
    S.iter
      (fun (elo_str, fml) ->
        match fml with
        | Ltl.True -> ()
        | _ ->
            pf out "%s@\nINVAR@\n@[<hv2>%a@];@\n@\n" elo_str
              (Ltl.pp_gather_variables bitwidth auxiliaries variables)
              fml)
      invariant;
    Format.pp_close_box out ();
    (* TRANS *)
    Format.pp_open_vbox out 0;
    S.iter
      (fun (elo_str, fml) ->
        let stratified_fml = Ltl.stratify ~smv_section:`Trans fml in
        pf out "%s@\n" elo_str;
        List.iter
          (pf out "TRANS@\n@[<hv2>%a@];@\n@\n"
             (Ltl.pp_gather_variables ~next_is_X:false bitwidth auxiliaries
                variables))
          stratified_fml)
      trans;
    Format.pp_close_box out ();
    (* LTLSPEC *)
    Format.pp_open_vbox out 0;
    let prop_str, ltlspec = property in
    let stratified_ltlspec =
      Ltl.conj @@ Ltl.stratify ~smv_section:`Ltlspec ltlspec
    in
    pf out "%s@\nLTLSPEC@\n@[<hv2>%a@];@\n@\n" prop_str
      (Ltl.pp_gather_variables bitwidth auxiliaries variables)
      stratified_ltlspec;
    Format.pp_close_box out ();
    (* HANDLING VARIABLES *)
    (* sorting before filtering (even when sorting after again) is more
       efficient on a few tests *)
    let sort_atomics atoms = S.sort_uniq ~cmp:Ltl.Atomic.compare atoms in
    variables := sort_atomics !variables;
    (* filter variables on frozen/var *)
    let r, f =
      S.fold
        (fun (acc_r, acc_f) at ->
          if Ltl.Atomic.is_const at then
            (* rigid / const *)
            (S.cons at acc_r, acc_f)
          else (* flexible / var *)
            (acc_r, S.cons at acc_f))
        (S.empty, S.empty)
        !variables
      |> fun (res_r, res_f) ->
      (sort_atomics res_r, sort_atomics res_f)
    in
    (*S.iter (fun v -> Format.printf "r_plain %a\n" Ltl.Atomic.pp v) r_plain;
    S.iter (fun v -> Format.printf "r_enum %a\n" Ltl.Atomic.pp v) r_enum;
    S.iter (fun v -> Format.printf "f_plain %a\n" Ltl.Atomic.pp v) f_plain;
    S.iter (fun v -> Format.printf "f_enum %a\n" Ltl.Atomic.pp v) f_enum;
    S.iter (fun v -> Format.printf "auxiliary %a\n" Symbol.pp v) !auxiliaries;*)
    (* FROZENVAR *)
    pp_decls elo "FROZENVAR" out r;
    (* VAR *)
    pp_decls elo "VAR" out f;
    (* VAR / AUXILIARY *)
    Iter.iter (fun at -> pf out "VAR %a : boolean;@\n" Symbol.pp at)
    @@ Iter.sort_uniq ~cmp:Symbol.compare !auxiliaries;
    (* close printing *)
    Format.pp_print_flush out ();
    Format.pp_set_margin out old_margin;
    (* return the number of variables *)
    S.length !variables

  let pp ?(margin = 80) out { elo; init; invariant; trans; property } =
    ignore
      (pp_count_variables ~margin out { elo; init; invariant; trans; property })

  (* write in temp file *)
  let make_model_file dir infile pp_generated model =
    let src_file = Filename.basename infile in
    let tgt = Filename.temp_file ~temp_dir:dir (src_file ^ "-") ".smv" in
    let nbvars = ref 0 in
    IO.with_out tgt (fun out ->
        let open Format in
        let chan = formatter_of_out_channel out in
        (if not pp_generated then
         (* no pretty-printing => redefine indentation function to output nothing *)
         let out_funs = pp_get_formatter_out_functions chan () in
         let out_funs =
           { out_funs with out_indent = (fun _ -> out_funs.out_string "" 0 0) }
         in
         pp_set_formatter_out_functions chan out_funs);
        nbvars := pp_count_variables chan model);
    (tgt, !nbvars)

  let make_script_file bmc dir script =
    let tgt = Filename.temp_file ~temp_dir:dir "electrod-" ".scr" in
    let first_line =
      match bmc with
      | None -> ""
      | Some length -> "set bmc_length " ^ string_of_int length ^ "; "
    in
    (match script with
    | Solver.File filename ->
        (* script given on the command line *)
        (* prepend first line then append given script *)
        IO.with_out tgt (fun out ->
            IO.write_line out first_line;
            IO.with_in filename (fun inp ->
                let chunks = IO.read_chunks_gen inp in
                IO.write_gen out chunks))
    | Solver.Default default ->
        IO.with_out tgt (fun out -> IO.write_line out (first_line ^ default)));
    tgt

  module ListAssoc = struct
    
    let to_yojson key_to_yojson value_to_yojson assoc_list =
      `Assoc (
        List.map (fun (key, value) -> match key_to_yojson key with
            | `String s -> (s, value_to_yojson value)
            | _ -> failwith "key must be string"
        ) assoc_list
      )
    let of_yojson key_of_yojson value_of_yojson json =
      match json with
      | `Assoc lst ->
          let rec convert acc = function
            | [] -> Ok (List.rev acc)
            | (key, value_json) :: xs -> (
                match key_of_yojson (`String key), value_of_yojson value_json with
                | Ok key, Ok value -> convert ((key, value) :: acc) xs
                | Error e, _ | _, Error e -> Error ("ListAssoc.of_yojson failed: " ^ e)
            )
          in
          convert [] lst
      | _ -> Error "Expected a JSON object"
  end

  type elo_info_t = {
    nbvars : int;
    domain : Domain.t;
    atom_renaming : (Atom.t, Atom.t) List.Assoc.t;
    name_renaming : (Name.t, Name.t) List.Assoc.t;
    smv_atoms : Yojson.Safe.t;
  } 
  
  let elo_info_to_yojson (elo_info : elo_info_t) : Yojson.Safe.t =
    `Assoc [
      ("nbvars", `Int elo_info.nbvars);
      ("domain", Domain.to_yojson elo_info.domain);
      ("atom_renaming", ListAssoc.to_yojson Atom.to_yojson Atom.to_yojson elo_info.atom_renaming);
      ("name_renaming", ListAssoc.to_yojson Name.to_yojson Name.to_yojson elo_info.name_renaming);
      ("smv_atoms",elo_info.smv_atoms)
    ]
  let elo_info_of_yojson (json : Yojson.Safe.t) : (elo_info_t, string) result =
    match json with
    | `Assoc fields -> 
        let open Result in
        let find_field name =
          match List.assoc_opt ~eq:String.equal name fields with
          | Some v -> Ok v
          | None -> Error ("Missing field: " ^ name)
        in
        find_field "nbvars" >>= (function
          | `Int nbvars -> Ok nbvars
          | _ -> Error "nbvars must be an int")
        >>= fun nbvars ->
        find_field "domain" >>= Domain.of_yojson
        >>= fun domain ->
        find_field "atom_renaming" >>= ListAssoc.of_yojson Atom.of_yojson Atom.of_yojson
        >>= fun atom_renaming ->
        find_field "name_renaming" >>= ListAssoc.of_yojson Name.of_yojson Name.of_yojson
        >>= fun name_renaming ->
        find_field "smv_atoms"
        >>= fun smv_atoms ->
        Ok { nbvars; domain; atom_renaming; name_renaming; smv_atoms }
    | _ -> Error "Expected a JSON object"
  
  let make_elo_info (nbvars : int) domain atom_renaming name_renaming =
      let smv_atoms = Ltl.Atomic.dump () in
      { nbvars = nbvars; domain = domain; atom_renaming = atom_renaming; name_renaming = name_renaming; smv_atoms = smv_atoms }

  let parseNuSmvOutput conversion_time analysis_time (cmd : string) elo_info (spec : string Gen.gen) = 
      (*let musts = Domain.musts ~with_univ_and_ident:false elo_info.domain in*)
      (* nuXmv says there is a counterexample so we parse it on the standard
         output *)
      (* first create a trace parser (it is parameterized by [base] below
         which tells the parser the "must" associated to every relation in the
         domain, even the ones not present in the SMV file because they have
         been simplified away in the translation. This goes this way because
         the trace to return should reference all relations, not just the ones
         grounded in the SMV file.). NOTE: the parser expects a nuXmv trace
         using the "trace plugin" number 1 (classical output (i.e. no XML, no
         table) with information on all variables, not just the ones that have
         changed w.r.t. the previous state.). *)
      let module P = Smv_trace_parser.Make (struct
        let base = (*musts*) failwith "TODO not implemented"
      end) in
      let trace =
        spec
        (* With this trace output, nuXmv shows a few uninteresting lines first,
           that we have to gloss over *)
        |> Gen.drop_while (fun line -> not @@ String.prefix ~pre:"Trace" line)
        |> Gen.drop_while (String.prefix ~pre:"Trace")
        |> String.unlines_gen
        (* |> Fun.tap print_endline *)
        |> fun trace_str ->
        let lexbuf = Lexing.from_string trace_str in
        P.trace (Smv_trace_scanner.main Ltl.Atomic.split_string) lexbuf
      in
      if not @@ Outcome.loop_is_present trace then
        Msg.Fatal.solver_bug (fun args ->
            args cmd "trace is missing a loop state.")
      else
        let atom_back_renaming =
          List.map (fun (x, y) -> (y, x)) elo_info.atom_renaming
        in
        let name_back_renaming =
          List.map (fun (x, y) -> (y, x)) elo_info.name_renaming
        in
        Outcome.trace
          (atom_back_renaming, name_back_renaming)
          elo_info.nbvars conversion_time analysis_time trace

  let write_elo_info_to_file file elo_info = 
      let fileinfo = (Filename.chop_extension file ^ ".info") in
      Logs.app (fun m -> m "Dumping electrod state to file %s" fileinfo);
      let json = elo_info_to_yojson elo_info in
      Yojson.Safe.to_file fileinfo json

  let write_elo_to_file file nbvars elo = 
      let elo_info = make_elo_info nbvars elo.Elo.domain elo.atom_renaming elo.name_renaming in 
      write_elo_info_to_file file elo_info

  let read_elo_info_from_file file_path =
    try
      let json = Yojson.Safe.from_file file_path in
      match elo_info_of_yojson json with
      | Ok elo_info -> Ok elo_info
      | Error msg -> Error ("Failed to parse elo_info: " ^ msg)
    with
    | Yojson.Json_error msg -> Error ("JSON Error: " ^ msg)
    | Sys_error msg -> Error ("File Error: " ^ msg)

  let validity_check bmc line =
    match bmc with
    | None -> String.mem ~sub:"is true" line
    | Some length ->
        let valid_bmc_string =
          "-- no counterexample found with bound " ^ string_of_int length
        in
        String.mem ~sub:valid_bmc_string line
        
  let gen_spec bmc okout =
    let spec =
      String.lines_gen okout
      |> Gen.drop_while (fun line ->
             (not @@ String.mem ~sub:"is false" line)
             && (not @@ validity_check bmc line))
    in spec
    
  let backtrace ~bmc (infofile,outfile) : Outcome.t = 
      let before = Mtime_clock.now () in
      Logs.app (fun m -> m "Reading electrod info file @%s@" infofile);
      match read_elo_info_from_file infofile with
          | Ok elo_info -> 
              Logs.app (fun m -> m "Successfully read electrod info file @%s@" infofile);
              (*write_elo_info_to_file "test.info" elo_info;*)
              let time = Mtime.span before @@ Mtime_clock.now () in
              let ic = open_in outfile in
              let content = really_input_string ic (in_channel_length ic) in
              close_in ic;
              Ltl.Atomic.restore elo_info.domain elo_info.smv_atoms;
              let spec = gen_spec bmc content in
              Logs.app (fun m -> m "Processing tool output @%s@" outfile);
              parseNuSmvOutput time time "nuXmv" elo_info spec
          | Error msg -> failwith msg

  let analyze ~conversion_time ~cmd ~script ~keep_files ~no_analysis ~elo ~file
      ~bmc ~pp_generated model : Outcome.t =
    let keep_or_remove_files scr smv =
      if keep_files then
        if no_analysis then
          Logs.app (fun m ->
              m "@[<hv2>Keeping the script and SMV files at:@ %s@\n%s@]" scr smv)
        else Logs.app (fun m -> m "@[<hv2>Keeping the script and SMV files@]")
      else (
        Logs.info (fun m -> m "@[<hv2>Removing files:@ %s@\n%s@]" scr smv);
        (match script with
        | Solver.Default _ -> IO.File.remove_noerr scr
        | Solver.File _ -> ());
        IO.File.remove_noerr smv)
    in
    (* TODO check whether nuXmv is installed first *)
    let dir = Filename.dirname file in
    let scr = make_script_file bmc dir script in
    let before_generation = Mtime_clock.now () in
    let smv, nbvars = make_model_file dir file pp_generated model in
    let after_generation = Mtime_clock.now () in
    Msg.info (fun m ->
        let size, unit_ =
          let s = float_of_int @@ Unix.((stat smv).st_size) in
          if Float.(s < 1_024.) then (s, "B")
          else if Float.(s < 1_048_576.) then (s /. 1_024., "KB")
          else if Float.(s < 1_073_741_824.) then (s /. 1_048_576., "MB")
          else (s /. 1_073_741_824., "GB")
        in
        m "SMV file (size: %.0f%s) generated in %a" (Float.round size) unit_
          Mtime.Span.pp
          (Mtime.span before_generation after_generation));
    if no_analysis then (
      keep_or_remove_files scr smv;
      write_elo_to_file file nbvars elo;
      Outcome.no_trace nbvars conversion_time Mtime.Span.zero)
    else
      (* Inspired by nunchaku-inria/logitest/src/Misc.ml (BSD licence). *)
      let sigterm_handler =
        Sys.Signal_handle
          (fun _ ->
            print_endline "Received termination signal!";
            keep_or_remove_files scr smv;
            print_endline "Exiting";
            Unix.kill 0 Sys.sigterm;
            (* kill children *)
            exit 1)
      in
      let previous_handler = Sys.signal Sys.sigterm sigterm_handler in
      (* escape shell-interpreted characters when calling n*smv *)
      let smv =
        String.flat_map
          (function
            | '\'' -> "\\'"
            | '\"' -> "\\\""
            | '$' -> "\\$"
            | c -> String.of_char c)
          smv
      in
      (* TODO make things s.t. it's possible to set a time-out *)
      let to_call = Fmt.str "%s -source %s %s" cmd scr smv in
      Logs.info (fun m -> m "Starting analysis:@[<h2>@ %s@]" to_call);
      let before_run = Mtime_clock.now () in
      let okout, errout, errcode = CCUnix.call "%s" to_call in
      let after_run = Mtime_clock.now () in
      (* go back to default behavior *)
      Sys.set_signal Sys.sigterm previous_handler;
      let analysis_time = Mtime.span before_run after_run in
      if errcode <> 0 then
        Msg.Fatal.solver_failed (fun args -> args cmd scr smv errcode errout)
      else
        (* running nuXmv goes well: parse its output *)
        Msg.info (fun m -> m "Analysis done in %a" Mtime.Span.pp analysis_time);
      (* check for the "UNSAT" problems when relying on UMC or BMC  *)
      let spec = gen_spec bmc okout in
      keep_or_remove_files scr smv;
      let spec_s =
        match Gen.get spec with
        | None ->
            failwith
              ("Incorrectly handled SMV string:"
              ^ Fmt.to_to_string (Gen.pp String.pp) spec)
        | Some s -> s
      in
      if validity_check bmc spec_s then
        Outcome.no_trace nbvars conversion_time analysis_time
      else
        (*let musts = Domain.musts ~with_univ_and_ident:false elo.Elo.domain in*)
        let elo_info = make_elo_info nbvars elo.Elo.domain elo.atom_renaming elo.name_renaming in 
        parseNuSmvOutput conversion_time analysis_time cmd elo_info spec
end
